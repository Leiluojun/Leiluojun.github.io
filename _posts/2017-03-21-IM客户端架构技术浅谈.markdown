---
layout: post
title:  "IM客户端架构技术浅谈"
date:   2017-03-21 13:05:14 +0100
categories: jekyll theme
author: yuhj
cover: "https://upload.wikimedia.org/wikipedia/commons/thumb/d/d7/Meisje_met_de_parel.jpg/600px-Meisje_met_de_parel.jpg"
location: Beijing, China
description: 本人之前从事过一段时间Android端IM SDK的开发，期间也做了许多技术调研以及踩了很多坑，现在我统一介绍下一个IM APP的方方面面，包括技术选型（包括通讯方式，网络连接方式，协议选择）和常见问题。
---
### 前言
本人之前从事过一段时间Android端IM SDK的开发，期间也做了许多技术调研以及踩了很多坑，现在我统一介绍下一个IM APP的方方面面，包括技术选型（包括通讯方式，网络连接方式，协议选择）和常见问题。浅薄之见，望大家别见笑，欢迎给出批评意见。

### P2P还是服务器中转？
IM通讯方式无非两种选择：设备直连(P2P)和通过服务器中转。
#### P2P方式
> ###### P2P多见于局域网内聊天工具，典型的应用有:飞鸽传书、天网Maze等。这类软件在启动后一般做两件事情:
- 进行UDP广播:发送自己信息和接受同局域网内其他端信息；
- 开启TCP监听:等待其他端进行连接。<br>

详细的流程可以参考飞鸽传书源码。但是这种方式在有种种限制和不便:一方面它只适合在线的点对点消息传输，对离线，群组等业务支持不够。另一方面由于 NAT 的存在，使得不同局域网内机器互联难度大大上升，在某些网络类型(对称NAT)下无法建立连接。
### IM到底该用UDP还是TCP协议？
说到IM该用UDP还是TCP作为传输协议，这是个颇有争议的话题，各大社区每当此问题的出现必定是大片的不同声音。<br>

当然，UDP和TCP各有各的应用场景，作为IM来说，早期的IM因为服务端资源（服务器硬件、网络带宽等）比较昂贵且没有更好的办法来分担性能负载，所以很多时候会考虑使用UDP，这其中主要是早期的QQ为代表。

时至今日，TCP的服务端负载已经有了很好的解决方案，加之服务器资源成本的下降，目前很多IM、消息推送解决方案也都在使用TCP作为传输层协议。不过，UDP也并未排除在IM、消息推送的解决方案之外，比如：弱网络通信（包括跨国的高延迟网络环境）、物联网通信、IM中的实时音视频通信等等场景下，UDP依然是首选项(比如飞信)。


### 该选择什么样的网络通讯技术？
##### IM主流网络通讯技术有两种:
- 基于TCP的长连接；
- 基于HTTP短连接PULL的方式。

后者常见于WEB IM系统(当然现在很多WEB IM都是基于WebSocket实现)，它的优点是实现简单，方便开发上手，问题是流量大，服务器负载较大，消息及时性无法很好地保证，对大规模的用户量支持不够，比较适合小型的IM系统,如小网站的客户系统。<br>

基于TCP长连接则能够更好地支持大批量用户，问题是客户端和服务器的实现比较复杂。

### 协议如何制定？
IM协议选择原则一般是：易于拓展，方便覆盖各种业务逻辑，同时又比较节约流量。后一点的需求在移动端IM上尤其重要。常见的协议有：XMPP、MQTT、私有协议。
#### XMPP
- 优点：协议开源，可拓展性强，在各个端(包括服务器)有各种语言的实现，开发者接入方便；
- 缺点：缺点也是不少，XML表现力弱、有太多冗余信息、流量大，实际使用时有大量天坑。

很多开发者为了节省开发成本，大多选择了XMPP协议。
#### MQTT
- 优点：协议简单，流量少；
- 缺点：它并不是一个专门为IM设计的协议，多使用于推送。

#### 私有协议
- 优点：高效，节约流量(一般使用二进制协议)，安全性高，难以破解；
- 缺点：在开发初期没有现有样列可以参考，对于设计者的要求比较高。

市面上几乎所有主流IM SDK都是是使用私有协议，一个被良好设计的私有协议优点非常明显。
##### 结论
一个好的协议需要满足如下条件:高效，简洁，可读性好，节约流量，易于拓展，同时又能够匹配当前团队的技术堆栈。基于如上原则，我们可以得出:如果团队小，团队技术在IM上积累不够可以考虑使用XMPP或者MQTT+HTTP短连接的实现。反之可以考虑自己设计和实现私有协议

### 该如何设计私有通信协议？
##### 序列化与反序列化
移动互联网相对于有线网络最大特点是:带宽低，延迟高，丢包率高和稳定性差，流量费用高。所以在私有协议的序列化上一般使用二进制协议，而不是文本协议。

常见的二进制序列化库有`protobuf`和`MessagePack`，当然你也可以自己实现自己的二进制协议序列化和反序列的过程，比如蘑菇街的TeamTalk。但是前面二者无论是可拓展性还是可读性都非常优秀，所以大部分情况下还是不推荐自己去实现二进制协议的序列化和反序列化过程。

##### 强列建议使用Protobuf，理由如下：
- `灵活、高效`：灵活（方便接口更新）、高效（效率经过google的优化，传输效率比普通的XML等高很多）；
- `易于使用`：开发人员通过按照一定的语法定义结构化的消息格式，然后送给命令行工具，工具将自动生成相关的类，可以支持java、c++、python等语言环境。通过将这些类包含在项目中，可以很轻松的调用相关方法来完成业务消息的序列化与反序列化工作。
- `语言支持`：原生支持c++、java、python等多达10余种语言。

一条消息数据用Protobuf序列化后的大小是JSON的1/10、XML格式的1/20、是二进制序列化的1/10。

##### 协议格式设计
基于TCP的应用层协议一般都分为包头和包体(如HTTP)，IM协议也不例外。包头一般用于表示每个请求/反馈的公共部分，如包长，请求类型，返回码等。 而包头则填充不同请求/反馈对应的信息。<br>

 
	public class ClientBytesParser {

    /**
     *  协议头（2 byte）：
     */
    public static final int PROTOCOL_HEADRE;

    /**
     * 0x01 （目前为第一个版本）
     */
    public static final int PROTOCOL_VERSION  ;

    /**
     * 比特标志位（1 byte）： 0 ack，是否需要消息回执 1 zip，body是否压缩 2~7为保留位
     */
    public static final int PROTOCOL_MRAK;

    /**
     * 表示请求类型或body的类型
     */
    public static final int PROTOCOL_TYPE;

    /**
     * length（2 byte）：body长度
     */
    public static final int PROTOCOL_LENGTH;

    /**
     * RPC （2 byte）：rpc请求的id，需要对方原样返回
     */
    public static final int PROTOCOL_RPC;
    
    
    }
    
    
协议格式可以根据各自的业务需求设置不同，但统一的原则是尽可能的精简，以减少请求的数据量。





 